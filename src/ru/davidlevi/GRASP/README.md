# GRASP паттерны проектирования

https://ru.wikipedia.org/wiki/GRASP 

## 1. Информационный эксперт (Information Expert)

**Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.**

Повышает:
- Инкапсуляцию;
- Простоту восприятия;
- Готовность компонентов к повторному использованию;

Снижает:
- степень зацепления.

Пример:
```java
class Blog {
    String getTitle(){
        return "Заголовок данного блога";
    }
    
    String getAuthor() {
        return "Автор данного блога";
    }
    
    // Возвращает число записей в данном блоге
    int getCountRecords(){
        return 100;
    }
}
```

## 2. Создатель (Creator)

**Какие условия должны соблюстись, что бы объекты верно порождали друг друга.**

Для этого есть несколько правил:
объект А должен порождать объект Б, если:
- объект А содержит или агрегирует объекты Б *(содержит в себе как свойство или коллекцию)*
- объект А активно использует объекты Б *(основной объем работы с объектом Б происходит посредством объекта А)*
- объект А обладает данными инициализации объекта Б *(каждый раз при создании объекта Б, данные берутся из объекта А)*

Пример:
```java
// Экземпляры класса Post должны создаваться внутри класса Blog, а Comment — в Post.

class Comment {
}

class Post {
    void createComment() {
        Comment comment = new Comment();
    }
}

class Blog {
    void createPost() {
        Post post = new Post();
    }
}
```
См. паттерны: "Фабрика", "Абстрактная фабрика"

## 3. Контроллер (Controller)

**Это не что иное, как C из аббревиатуры MVC. Этот шаблон отвечает за то, к кому именно должны обращаться вызовы из V (View), и кому C должен делегировать запросы 
на выполнение (какая модель M должна их обработать)**

1. Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление);
2. Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;
3. Может представлять собой:
- Систему в целом;
- Подсистему;
- Корневой объект;
- Устройство.

## 4. Низкая связанность (Low Coupling)

**Отвечает за то, что бы объекты в системе знали друг о друге как можно меньше.**

Позволяет избежать проблемы:
- При изменении в связанных классах, необходимо делать локальные изменения в данном классе
- Понимание каждого класса в отдельности усложняется и требует изучения всех связанных классов
- Повторное использование становится невозможным из-за того, что перетянув часть системы, необходимо тянуть почти всю систему.

Пример:
```java 
// Blog ничего не знает о Comment, а степени связанности у каждого класса составляют всего лишь единицу.

class Comment {
}

class Post {
    void createComment() {
        Comment comment = new Comment();
    }
}

class Blog {
    void createPost() {
        Post post = new Post();
    }
}
```

## 5. Высокое зацепление (High Cohesion)

**Высокое зацепление**- это оценочная модель, направленная на удержание объектов должным образом сфокусированными, управляемыми и понятными. 
Высокое зацепление обычно используется для поддержания низкой связанности. 
Высокое зацепление означает, что обязанности данного элемента тесно связаны и сфокусированы. Разбиение программ на 
классы и подсистемы является примером деятельности, которая увеличивает связанность системы.

**Низкое зацепление** — это ситуация, при которой данный элемент имеет слишком много несвязанных обязанностей. Элементы с низким зацеплением часто страдают от того, что их трудно понять, трудно использовать, трудно поддерживать.

Зацепление класса — мера сфокусированности предметных областей его методов:
- «Высокое» зацепление — сфокусированные подсистемы (предметная область определена, управляема и понятна);
- «Низкое» зацепление — абстрактные подсистемы. Затруднены: восприятие, повторное использование, поддержка, устойчивость к внешним изменениям.

Пример 1
```java
public class MainClass {
    public static void main(String[] args) {
        Multiply m = new Multiply();
        System.out.println(m.mul(5, 5));
    }
}

class Multiply {
    int a = 5;
    int b = 5;

    public int mul(int a, int b) {
        this.a = a;
        this.b = b;
        return a * b;
    }
}
```

Пример 2
```java
public class MainClass {
    public static void main(String[] args) {
        Name name = new Name();
        System.out.println(name.getName("David"));
        
        Age age = new Age();
        System.out.println(age.getAge(10));
        
        Number number = new Number();
        System.out.println(number.getNumber(1234107891));
    }
}

class Name {
    String name;

    public String getName(String name) {
        this.name = name;
        return name;
    }
}

class Age {
    int age;

    public int getAge(int age) {
        this.age = age;
        return age;
    }
}

class Number {
    int mobileno;

    public int getNumber(int mobileno) {
        this.mobileno = mobileno;
        return mobileno;
    }
}  
```

## 6. Полиморфизм (Polymorphism)

Устройство и поведение системы:
- Определяется данными;
- Задано полиморфными операциями её интерфейса.

Пример: Адаптация коммерческой системы к многообразию систем учёта налогов может быть обеспечена через внешний интерфейс 
объектов-адаптеров (см. паттерн «Адаптер»).

```java
public class MainClass {
    public static void main(String[] args) {
        Deer deer = new Deer(); // олень имеет формы:
        Animal animal = deer; // форма 1
        Vegetarian vegetarian = deer; // форма 2
        Object object = deer; // форма 3
    }
}

// Поведение
interface Vegetarian {
}

// Животное
class Animal {
}

// Олень
class Deer extends Animal implements Vegetarian {
}
```

## 7. Чистая выдумка (Pure Fabrication)

Не относится к предметной области, но:
- Уменьшает связность;
- Повышает зацепление;
- Упрощает повторное использование.

«Pure Fabrication» отражает концепцию сервисов в модели проблемно-ориентированного проектирования.

**Пример 1:** Не используя средства класса «А», внести его объекты в базу данных.

**Решение:** Создать класс «Б» для записи объектов класса «А» (смотрите также: «Data Access Object»).

**Пример 2:**, классу X необходимо сохранять информацию в реляционной базе данных. Согласно шаблону Information Expert, эту обязанность можно присвоить самому классу X. Однако следует принять во внимание, что Данная задача требует достаточно большого числа специализированных операций, поэтому класс X будет иметь низкую степень зацепления, класс X будет связан с интерфейсом БД, что повысит связность, кроме того задача записи в БД является довольно общей, поэтому необходимо обеспечить повторное использование кода.
 
**Решение:** Естественным решением данной проблемы является создание нового класса, ответственного за сохранение объектов некоторого вида на постоянном носителе, например в реляционной базе данных. Его можно назвать PersistentStorage. Это чисто синтетический объект, что полностью соответствует Pure Fabrication. В итоге решаются задачи зацепления, связности и повторного использования.

**Пример 3:**, итак — ситуация. Какой класс должен сохранять наш объект Sale в базу данных? Если подчиняется принципу «информационный эксперт», то Sale , но наделив его такой ответственностью мы получаем слабую сцепленность внутри него. 

**Решение:** Тогда можно найти выход, создав синтетическую сущность — SaleDao или SaleRepository , которая будет сильно сцеплена внутри и будет иметь единую ответственность — и правильно сохранять Sale в базу.

## 8. Посредник (Indirection)

См. паттерн Mediator (Посредник)

Слабая связность между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником.

**Пример:** В архитектуре Model-View-Controller, контроллер (англ. controller) ослабляет связность данных (англ. model) с их представлением (англ. view).

## 9. Устойчивость к изменениям (Protected Variations)

Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса.










