package ru.davidlevi.SOLID.D;

/**
 * D Принцип инверсии зависимостей
 * <p>
 * «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
 * <p>
 * Модули верхних уровней не должны зависеть от модулей нижних уровней.
 * Оба типа модулей должны зависеть от абстракций.
 * <p>
 * Абстракции не должны зависеть от деталей.
 * Детали должны зависеть от абстракций.
 */
public class MainClass {
    public static void main(String[] args) {

        // Есть некий класс В с публичным методом
        class B {
            void methodB() {
                System.out.println("Hello, David!");
            }
        }

        // Сначала рассмотрим прямую зависимость:
        class A {
            void methodA() {
                // Здесь класс А зависит от класса В напрямую!
                B b = new B();
                b.methodB();
            }
        }
        A a = new A();
        a.methodA();

        // Теперь реализуем инверсную (непрямую) зависимость
        class A1 {
            private final B b;

            // Здесь мы передали в констуктор класса А1 ссылку на объект В тем самым отвязались от прямой зависимости
            A1(B b) {
                this.b = b;
            }

            void someMethod() {
                b.methodB();
            }
        }
        B b = new B();
        A1 a1 = new A1(b);
        a1.someMethod();

        // Сделовательно инверсия зависимостей заключается в том, что, класс не создает зависимости самостоятельно,
        // а получает их в созданном виде в конструкторе (или иным образом).

        // Следовательно с инверсией зависимостей, в классе можно без изменения его кода заменить все зависимости, а
        // это означает, что ваш класс А можно гибко настроить для применения в другой программе, отличной от той для
        // которой он был написан изначально.
    }
}
